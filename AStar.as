	package com.jeremyclewell {	import flash.utils.getTimer;	import flash.display.*;	import flash.events.*;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.utils.ByteArray;		public class AStar extends Sprite {				private var CELL_SIZE:int = 5;		const GRID_WIDTH = 250;		const GRID_HEIGHT = 250;				//these are the states available for each cell.		const CELL_FREE = 0;		const CELL_FILLED = 1;		const CELL_ORIGIN = 2;		const CELL_DESTINATION = 3;				var mapArray:Array;		var mapArrayTemplate:Array;		var originCell:Object;		var destinationCell:Object;		var currentCell:Object;		var key:BitmapData;				var openList:Array;		var closedList:Array;		var pathList:Array;		public var counter:int = 0;				var tmpDrwgSrfc:Sprite;		var tmpDrwgSrfc2:Sprite;		//This class take a "key" image to build the walkable grid from		public function AStar(key:BitmapData, startNode:Vector.<int>, endNode:Vector.<int>, cellSize:int, debug:Boolean = false) {			var duration:uint = getTimer(); // Start Timing						tmpDrwgSrfc2 = new Sprite();			addChild(tmpDrwgSrfc2);			tmpDrwgSrfc = new Sprite();			addChild(tmpDrwgSrfc);						CELL_SIZE = cellSize;						originCell = new Object();			destinationCell = new Object();			currentCell = new Object();						openList = new Array();			closedList = new Array();			pathList = new Array();						this.key = key;						//define map			mapArray = new Array();			//var xx:int = 0;			//var yy:int = 0;			for (var xx:int = 0; xx < key.width / CELL_SIZE; xx++) {				mapArray[xx] = new Array();				for (var yy:int = 0; yy < key.height / CELL_SIZE; yy++) {					mapArray[xx][yy] = new Object();					mapArray[xx][yy].cellType = (key.getPixel(xx * CELL_SIZE,yy * CELL_SIZE) != 16777215) ? CELL_FREE : CELL_FILLED;// uint represents the color we're checking against						mapArray[xx][yy].parentCell = null;					mapArray[xx][yy].g = 0;					mapArray[xx][yy].score = 0;					mapArray[xx][yy].x = xx;					mapArray[xx][yy].y = yy;				}			}			var copier:ByteArray = new ByteArray();			copier.writeObject(mapArray);			copier.position = 0;			mapArrayTemplate = copier.readObject();												mapArray[startNode[0]][startNode[1]].cellType = CELL_ORIGIN;			currentCell = mapArray[startNode[0]][startNode[1]];			originCell = currentCell;			closedList.push(currentCell);			mapArray[endNode[0]][endNode[1]].cellType = CELL_DESTINATION;			destinationCell = mapArray[endNode[0]][endNode[1]];						tmpDrwgSrfc.graphics.clear();			tmpDrwgSrfc2.graphics.clear();			if (debug) drawMap();			trace("Initiallized in: " + (getTimer() - duration).toString() + " miliseconds");		}								public function findSolution():void {			var duration:uint = getTimer();						while (currentCell != destinationCell) {								//place current cell into openList				openList.push(currentCell);									//----------------------------------------------------------------------------------------------------				//place all legal adjacent squares into a temporary array				//----------------------------------------------------------------------------------------------------				var tempArry:Array = new Array();				var arryPtr:Object;											if(currentCell.y >= 1) { //rule out cells off the grid					arryPtr = mapArray[currentCell.x][currentCell.y-1];					if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					if(currentCell.x >= 1) {						arryPtr = mapArray[currentCell.x-1][currentCell.y-1];						if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					}				}								if(currentCell.x >= 1) { //rule out cells off the grid					arryPtr = mapArray[currentCell.x-1][currentCell.y];					if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					if(currentCell.y < GRID_HEIGHT - 1) {						arryPtr = mapArray[currentCell.x-1][currentCell.y+1];						if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					}				}								if(currentCell.y < GRID_HEIGHT - 1) { //rule out cells off the grid					arryPtr = mapArray[currentCell.x][currentCell.y+1];					if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					if(currentCell.x < GRID_WIDTH - 1) {						arryPtr = mapArray[currentCell.x+1][currentCell.y+1];						if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					}									}								if(currentCell.x < GRID_WIDTH - 1) { //rule out cells off the grid					arryPtr = mapArray[currentCell.x+1][currentCell.y];					if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					if(currentCell.y >= 1) {						arryPtr = mapArray[currentCell.x+1][currentCell.y-1];						if(arryPtr.cellType != CELL_FILLED && closedList.indexOf(arryPtr) == -1) tempArry.push(arryPtr);					}				}												//add legal adjacent cells from above to the open list				for(var ii = 0; ii < tempArry.length; ii++) {										if(openList.indexOf(tempArry[ii]) == -1) { //is cell already on the open list?																	var g:int = Math.abs(currentCell.x - tempArry[ii].x) + Math.abs(currentCell.y - tempArry[ii].y) + currentCell.g;						tempArry[ii].parentCell = currentCell;						tempArry[ii].score = Math.abs(destinationCell.x - tempArry[ii].x) + Math.abs(destinationCell.y - tempArry[ii].y) + tempArry[ii].g;						tempArry[ii].g = g;											openList.push(tempArry[ii]);						//trace("score: " + tempArry[ii].score);					} else { //cell IS already on the open list.						//current cell is already on the open list, so it was reached in THIS case by a different path.						//see if the current path (from the origin) is shorter than the existing path.						//TODO					}				}								//handle the case where there is no solution				if(openList.length == 0) {					// Draw x over icon					return;				}												//Remove current cell from openList and add to closedList.				var indexOfCurrent = openList.indexOf(currentCell);				closedList.push(currentCell);				openList.splice(indexOfCurrent, 1);								//Take the lowest scoring openList cell and make it the current cell.				openList.sortOn("score", Array.NUMERIC | Array.DESCENDING);					currentCell = openList.pop();								//Draw new location of currentCell.				tmpDrwgSrfc.graphics.clear();				tmpDrwgSrfc2.graphics.clear();				//fillRect(tmpDrwgSrfc.graphics, currentCell.x, currentCell.y, 0x888888);			}										if (currentCell == destinationCell) {				trace("Found solution in: " + (getTimer() - duration).toString() + " miliseconds");				var cellPointer:Object = closedList[closedList.length - 1];				counter = 0;				var duration2:uint = getTimer();				while(cellPointer != originCell) {					counter++					tmpDrwgSrfc.graphics.moveTo(cellPointer.x * CELL_SIZE + CELL_SIZE/2, cellPointer.y * CELL_SIZE + CELL_SIZE/2);					tmpDrwgSrfc2.graphics.moveTo(cellPointer.x * CELL_SIZE + CELL_SIZE/2, cellPointer.y * CELL_SIZE + CELL_SIZE/2);					cellPointer = cellPointer.parentCell;									tmpDrwgSrfc.graphics.lineStyle(10, 0x4cb505);					tmpDrwgSrfc2.graphics.lineStyle(16, 0xFFFFFF);					tmpDrwgSrfc.graphics.lineTo(cellPointer.x * CELL_SIZE + CELL_SIZE/2, cellPointer.y * CELL_SIZE + CELL_SIZE/2);					tmpDrwgSrfc2.graphics.lineTo(cellPointer.x * CELL_SIZE + CELL_SIZE/2, cellPointer.y * CELL_SIZE + CELL_SIZE/2);				}				trace("Drawing took: " + (getTimer() - duration2).toString() + " miliseconds");				trace(counter);				}							}									//need to make this work.		private function drawMap():void {			//draw cells			graphics.clear();			for(var xx:int = 0; xx < key.width / CELL_SIZE; xx++) {				for(var yy:int = 0; yy < key.height / CELL_SIZE; yy++) {					if(mapArray[xx][yy].cellType == CELL_FILLED) {						fillRect(graphics, xx, yy, 0xAA0000);					}					if(mapArray[xx][yy].cellType == CELL_ORIGIN) {						fillRect(graphics, xx, yy, 0x00AA00);					}					if(mapArray[xx][yy].cellType == CELL_DESTINATION) {						fillRect(graphics, xx, yy, 0x0000AA);					}				}			}			//draw grid			graphics.lineStyle(2, 0xAAAAAA);			var ii:int = 0;			for(ii = CELL_SIZE; ii < key.width; ii += CELL_SIZE) {				graphics.moveTo(ii, 0);				graphics.lineTo(ii, key.height);			}			for(ii = CELL_SIZE; ii < key.height; ii += CELL_SIZE) {				graphics.moveTo(0, ii);				graphics.lineTo(key.width, ii);			}		}				private function fillRect(target:Graphics, cellX:int, cellY:int, color:int) {						target.lineStyle(5, color);			target.moveTo(cellX * CELL_SIZE + 2, cellY * CELL_SIZE + 2);			target.beginFill(color, 0.5);						target.drawRect(cellX * CELL_SIZE + 2, cellY * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);			//target.drawCircle(cellX * CELL_SIZE, cellY * CELL_SIZE, 10);			target.endFill();		}										public function updatePathOrigin(originX:int, originY:int):Boolean {							var duration2:uint = getTimer();			var isPath:Boolean = false;			openList = new Array();			closedList = new Array();															for (var xx:int = 0; xx < key.width / CELL_SIZE; xx++) {				for (var yy:int = 0; yy < key.height / CELL_SIZE; yy++) {					mapArray[xx][yy].parentCell = null;					mapArray[xx][yy].g = 0;					mapArray[xx][yy].score = 0;				}			}			var cellX = int(originX / CELL_SIZE);			var cellY = int(originY / CELL_SIZE);			if (mapArray[cellX][cellY].cellType == CELL_FREE) {				mapArray[cellX][cellY].cellType = CELL_ORIGIN;				originCell.cellType = CELL_FREE;				currentCell = mapArray[cellX][cellY];				originCell = currentCell;				closedList.push(currentCell);				try {					findSolution();					isPath = true;				} 				catch (e) {				}			} 			return isPath;		}				public function updatePathEnd(endX:int, endY:int):Boolean {			var isPath:Boolean = false;			openList = new Array();			closedList = new Array();												var duration2:uint = getTimer();			for (var xx:int = 0; xx < key.width / CELL_SIZE; xx++) {				for (var yy:int = 0; yy < key.height / CELL_SIZE; yy++) {					mapArray[xx][yy].parentCell = null;					mapArray[xx][yy].g = 0;					mapArray[xx][yy].score = 0;				}			}			var cellX = int(endX / CELL_SIZE);			var cellY = int(endY / CELL_SIZE);			if (mapArray[cellX][cellY].cellType == CELL_FREE) {				mapArray[cellX][cellY].cellType = CELL_DESTINATION;				destinationCell.cellType = CELL_FREE;				currentCell = originCell;				destinationCell = mapArray[cellX][cellY];				closedList.push(originCell);				try {					findSolution();					isPath = true;				} 				catch (e) {				}			} 			return isPath;		}				public function isOnPath(evt:MouseEvent):Boolean {			var cellX = int(evt.stageX/ CELL_SIZE);			var cellY = int(evt.stageY / CELL_SIZE);			pathList = new Array();			var cellPointer:Object = destinationCell;			while(cellPointer != originCell && cellPointer != null) {				for (var xx:int = 0; xx < 10; xx++) {					for (var yy:int = 0; yy < 10; yy++) {						if (pathList.indexOf(mapArray[cellPointer.x + xx][cellPointer.y + yy]) == -1) pathList.push(mapArray[cellPointer.x + xx][cellPointer.y + yy]);						if (pathList.indexOf(mapArray[cellPointer.x - xx][cellPointer.y + yy]) == -1) pathList.push(mapArray[cellPointer.x - xx][cellPointer.y + yy]);						if (pathList.indexOf(mapArray[cellPointer.x + xx][cellPointer.y - yy]) == -1) pathList.push(mapArray[cellPointer.x + xx][cellPointer.y - yy]);						if (pathList.indexOf(mapArray[cellPointer.x - xx][cellPointer.y - yy]) == -1) pathList.push(mapArray[cellPointer.x - xx][cellPointer.y - yy]);					}				}				cellPointer = cellPointer.parentCell;							}			return (pathList.indexOf(mapArray[cellX][cellY]) > -1) ? true : false;		}	}}